JavaScript restrict mode
------------------------
Restrict mode reduces the amount of type coercion by providing strict
versions of built-in loose operators, similar to how === is already a
strict version of the loose == operator.

Restrict mode adds functions but no new syntax. There's a translator
that automatically converts loose operators into their restrict mode
equivalent, such as a < b into __lt(a, b). The translator preserves as
much of the original source and formatting as possible, and tries to
produce as readable output as possible.

Restrict mode is enabled similar to ECMAScript 5 strict mode. Include
the statement "use restrict"; at the top of your script or inside a
function. It is encouraged to combine the two:
"use strict"; "use restrict";

Since restrict mode is a subset of JavaScript, all valid restrict mode
programs will produce equivalent results whether compiled or not. The
opposite is not true, since restrict mode throws errors in cases where
type coercions would normally occur. One use-case is to use the
translated version when executing the unit-tests and the original
version for rapid iterative development and deployment.

It is possible to force the use of a loose operator even in restrict
mode.
    /*@loose*/ a < b + 1     annotation prepended to expression
                             or statement. Annotation has lowest
                             priority.

If a function is loose-annotated, restrict checking is disabled for
the whole body of that function:
/*@loose*/ function min(a, b) { return a < b ? a : b }
var min = /*@loose*/ function(a, b) { return a < b ? a : b }

Restrict mode semantics
-----------------------
A run-time exception is thrown if the restrictions are broken.

(0) === and !== are already strict by default. Use them!
(1) == and != are not allowed to type coerce, with one exception:
    undefined == null (true) and undefined != null (false)
(2) + += < <= >= > are restricted to strings or numbers (but never a mix)
(3) - * / % & | ^ ~v << >> >>> -v
    -= *= /= %= &= |= ^= <<= >>= >>>= are restricted to numbers
(4) That's it! (+v !v && || ?: and all other operators remain the same)

String formatting:
------------------
Alternatives to string concatenation via + operator
log("player " + name + " scored " + points " points ");

log(Fmt("player {0} scored {1} points", name, points));
log(Fmt.cat("player ", name, " scored ", points, " points "));

Operators:
----------
Operators without restrict equivalents, untranslated
  (mustn't be /*@loose*/ annotated in general):
===  strict by default
!==  strict by default
=    strict by default (doesn't coerce)
&&   calls toBoolean
||   calls toBoolean
!    calls toBoolean
?:   calls toBoolean
+n   calls toNumber, common shorthand for Number(n)
,    doesn't coerce
o.k  doesn't coerce
o[k] calls toString
other operators (for example delete, in, typeof, instanceof)

Equality (null/undefined, boolean, number, string, object, function):
==   __eq
!=   __ne

Comparision (number, string):
<    __lt
>    __gt
<=   __le
>=   __ge

Arithmetic:
+    __add (number addition, string concatenation)
-    __sub number
*    __mul number
/    __div number
%    __mod number
[same for += -= *= /= %=]
++n  __prefinc number
--n  __prefdec number
n++  __postinc number
n--  __postdec number
-n   __neg number

Bitwise arithmetic (number):
&    __bitand
|    __bitor
^    __bitxor
<<   __bitasl
>>   __bitasr
>>>  __bitlsr
~n   __bitnot
[same for &= |= ^= <<= >>= >>>=]


Restrict pedantic mode:
In restrict pedantic mode, the use of the loose == and != operators is
only valid when loose-annotated. For strict versions, use the built-in
=== and !== operators instead.
