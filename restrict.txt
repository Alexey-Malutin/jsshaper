A compiler that automatically converts a < b into __lt(a, b) could use
comments to force loose (non-strict) version, i.e: 

if (a /*loose*/ <= b)


Examples of issues with loose comparisions:
-------------------------------------------
[1] < [2] and [1,2] < [1,3] but [10] < [2] (coerced into "10" < "2")
1 + [[[2]]] === "12"
1 < true
n1 = new Number(3), n2 = Number(3)
   n1 <= n2, n2 >= n1 but n1 != n2

Date is special-case:
---------------------
(new Date()) + 1 === "Tue Dec 28 2010 23:59:53 GMT+0100 (CET)1" but
(new Date()) - 1 === 1293577193075

Falsy and truthy values:
------------------------
new Boolean(false) is truthy (object and not null)

Converting to primitive types:
------------------------------
To string: ""+ 101 or String(101)
To number: +"101" or Number("101")
To boolean: !!101 or Boolean(101)

String formatting:
------------------
Alternatives to string concatenation via + operator
log("player " + name + " scored " + points " points ");

log(String.fmt("player {0} scored {1} points", name, points));
log(String.str("player ", name, " scored ", points, " points "));
